(defun isprime (x)
  (if (< x 2)
    (return-from isprime nil)
    (dotimes (i (+ (ceiling (sqrt x)) 1))
      (if (> i 1)
        (if (< i x)
          (if (equal (mod x i) 0)
            (return-from isprime nil))))))
  (return-from isprime t))
(defun primes-from (numb)
  (let* ((n 0) (plist ()))
    (loop
       (when (> n numb) (return))
       (if (isprime n)
           (push n plist))
        (incf n))
    (setq returnvar (sort plist #'>))))
(defun sum-upto (lmt start)
  (let* ((n start) (limit lmt))
    (setq primes (sort (primes-from (floor (/ lmt 2))) #'<))
    (setq primestotal 0)
    (setq sum-array ())
    (setq lengths-array ())
    (loop
      (setq current-prime (elt primes n))
      (when (> (+ primestotal current-prime) limit) (return))
      (setq primestotal (+ current-prime primestotal))
      (if (isprime primestotal)
          (progn
            (push primestotal sum-array)
            (push (+ (- n start) 1) lengths-array)))
      (incf n))
      (print sum-array)
      (print lengths-array)))